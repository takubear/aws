"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkProvider = void 0;
const https = require("https");
const os = require("os");
const path = require("path");
const cxapi = require("@aws-cdk/cx-api");
const AWS = require("aws-sdk");
const fs = require("fs-extra");
const logging_1 = require("../../logging");
const functions_1 = require("../../util/functions");
const credential_plugins_1 = require("../aws-auth/credential-plugins");
const awscli_compatible_1 = require("./awscli-compatible");
const sdk_1 = require("./sdk");
// Some configuration that can only be achieved by setting
// environment variables.
process.env.AWS_STS_REGIONAL_ENDPOINTS = 'regional';
process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = '1';
const CACHED_ACCOUNT = Symbol('cached_account');
const CACHED_DEFAULT_CREDENTIALS = Symbol('cached_default_credentials');
/**
 * Creates instances of the AWS SDK appropriate for a given account/region
 *
 * If an environment is given and the current credentials are NOT for the indicated
 * account, will also search the set of credential plugin providers.
 *
 * If no environment is given, the default credentials will always be used.
 */
class SdkProvider {
    constructor(defaultChain, 
    /**
     * Default region
     */
    defaultRegion, sdkOptions = {}) {
        this.defaultChain = defaultChain;
        this.defaultRegion = defaultRegion;
        this.sdkOptions = sdkOptions;
        this.plugins = new credential_plugins_1.CredentialPlugins();
    }
    /**
     * Create a new SdkProvider which gets its defaults in a way that behaves like the AWS CLI does
     *
     * The AWS SDK for JS behaves slightly differently from the AWS CLI in a number of ways; see the
     * class `AwsCliCompatible` for the details.
     */
    static async withAwsCliCompatibleDefaults(options = {}) {
        var _a;
        const sdkOptions = parseHttpOptions((_a = options.httpOptions) !== null && _a !== void 0 ? _a : {});
        const chain = await awscli_compatible_1.AwsCliCompatible.credentialChain({
            profile: options.profile,
            ec2instance: options.ec2creds,
            containerCreds: options.containerCreds,
            httpOptions: sdkOptions.httpOptions,
        });
        const region = await awscli_compatible_1.AwsCliCompatible.region({
            profile: options.profile,
            ec2instance: options.ec2creds,
        });
        return new SdkProvider(chain, region, sdkOptions);
    }
    /**
     * Return an SDK which can do operations in the given environment
     *
     * The `environment` parameter is resolved first (see `resolveEnvironment()`).
     */
    async forEnvironment(environment, mode) {
        const env = await this.resolveEnvironment(environment);
        const creds = await this.obtainCredentials(env.account, mode);
        return new sdk_1.SDK(creds, env.region, this.sdkOptions);
    }
    /**
     * Return an SDK which uses assumed role credentials
     *
     * The base credentials used to retrieve the assumed role credentials will be the
     * current credentials (no plugin lookup will be done!).
     *
     * If `region` is undefined, the default value will be used.
     */
    async withAssumedRole(roleArn, externalId, region) {
        logging_1.debug(`Assuming role '${roleArn}'.`);
        region = region !== null && region !== void 0 ? region : this.defaultRegion;
        const creds = new AWS.ChainableTemporaryCredentials({
            params: {
                RoleArn: roleArn,
                ...externalId ? { ExternalId: externalId } : {},
                RoleSessionName: `aws-cdk-${os.userInfo().username}`,
            },
            stsConfig: {
                region,
                ...this.sdkOptions,
            },
            masterCredentials: await this.defaultCredentials(),
        });
        return new sdk_1.SDK(creds, region, this.sdkOptions);
    }
    /**
     * Resolve the environment for a stack
     *
     * Replaces the magic values `UNKNOWN_REGION` and `UNKNOWN_ACCOUNT`
     * with the defaults for the current SDK configuration (`~/.aws/config` or
     * otherwise).
     *
     * It is an error if `UNKNOWN_ACCOUNT` is used but the user hasn't configured
     * any SDK credentials.
     */
    async resolveEnvironment(env) {
        var _a;
        const region = env.region !== cxapi.UNKNOWN_REGION ? env.region : this.defaultRegion;
        const account = env.account !== cxapi.UNKNOWN_ACCOUNT ? env.account : (_a = (await this.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId;
        if (!account) {
            throw new Error('Unable to resolve AWS account to use. It must be either configured when you define your CDK or through the environment');
        }
        return {
            region,
            account,
            name: cxapi.EnvironmentUtils.format(account, region),
        };
    }
    /**
     * The account we'd auth into if we used default credentials.
     *
     * Default credentials are the set of ambiently configured credentials using
     * one of the environment variables, or ~/.aws/credentials, or the *one*
     * profile that was passed into the CLI.
     *
     * Might return undefined if there are no default/ambient credentials
     * available (in which case the user should better hope they have
     * credential plugins configured).
     *
     * Uses a cache to avoid STS calls if we don't need 'em.
     */
    defaultAccount() {
        return functions_1.cached(this, CACHED_ACCOUNT, async () => {
            try {
                const creds = await this.defaultCredentials();
                const accessKeyId = creds.accessKeyId;
                if (!accessKeyId) {
                    throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
                }
                return await new sdk_1.SDK(creds, this.defaultRegion, this.sdkOptions).currentAccount();
            }
            catch (e) {
                logging_1.debug('Unable to determine the default AWS account:', e);
                return undefined;
            }
        });
    }
    /**
     * Get credentials for the given account ID in the given mode
     *
     * Use the current credentials if the destination account matches the current credentials' account.
     * Otherwise try all credential plugins.
     */
    async obtainCredentials(accountId, mode) {
        var _a;
        // First try 'current' credentials
        const defaultAccountId = (_a = (await this.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId;
        if (defaultAccountId === accountId) {
            return this.defaultCredentials();
        }
        // Then try the plugins
        const pluginCreds = await this.plugins.fetchCredentialsFor(accountId, mode);
        if (pluginCreds) {
            return pluginCreds;
        }
        // No luck, format a useful error message
        const error = [`Need to perform AWS calls for account ${accountId}`];
        error.push(defaultAccountId ? `but the current credentials are for ${defaultAccountId}` : 'but no credentials have been configured');
        if (this.plugins.availablePluginNames.length > 0) {
            error.push(`and none of these plugins found any: ${this.plugins.availablePluginNames.join(', ')}`);
        }
        throw new Error(`${error.join(', ')}.`);
    }
    /**
     * Resolve the default chain to the first set of credentials that is available
     */
    defaultCredentials() {
        return functions_1.cached(this, CACHED_DEFAULT_CREDENTIALS, () => {
            logging_1.debug('Resolving default credentials');
            return this.defaultChain.resolvePromise();
        });
    }
}
exports.SdkProvider = SdkProvider;
/**
 * Get HTTP options for the SDK
 *
 * Read from user input or environment variables.
 *
 * Returns a complete `ConfigurationOptions` object because that's where
 * `customUserAgent` lives, but `httpOptions` is the most important attribute.
 */
function parseHttpOptions(options) {
    var _a;
    const config = {};
    config.httpOptions = {};
    let userAgent = options.userAgent;
    if (userAgent == null) {
        // Find the package.json from the main toolkit
        const pkg = JSON.parse((_a = readIfPossible(path.join(__dirname, '..', '..', '..', 'package.json'))) !== null && _a !== void 0 ? _a : '{}');
        userAgent = `${pkg.name}/${pkg.version}`;
    }
    config.customUserAgent = userAgent;
    const proxyAddress = options.proxyAddress || httpsProxyFromEnvironment();
    const caBundlePath = options.caBundlePath || caBundlePathFromEnvironment();
    if (proxyAddress && caBundlePath) {
        throw new Error(`At the moment, cannot specify Proxy (${proxyAddress}) and CA Bundle (${caBundlePath}) at the same time. See https://github.com/aws/aws-cdk/issues/5804`);
        // Maybe it's possible after all, but I've been staring at
        // https://github.com/TooTallNate/node-proxy-agent/blob/master/index.js#L79
        // a while now trying to figure out what to pass in so that the underlying Agent
        // object will get the 'ca' argument. It's not trivial and I don't want to risk it.
    }
    if (proxyAddress) { // Ignore empty string on purpose
        // https://aws.amazon.com/blogs/developer/using-the-aws-sdk-for-javascript-from-behind-a-proxy/
        logging_1.debug('Using proxy server: %s', proxyAddress);
        // eslint-disable-next-line @typescript-eslint/no-require-imports
        const ProxyAgent = require('proxy-agent');
        config.httpOptions.agent = new ProxyAgent(proxyAddress);
    }
    if (caBundlePath) {
        logging_1.debug('Using CA bundle path: %s', caBundlePath);
        config.httpOptions.agent = new https.Agent({
            ca: readIfPossible(caBundlePath),
            keepAlive: true,
        });
    }
    return config;
}
/**
 * Find and return the configured HTTPS proxy address
 */
function httpsProxyFromEnvironment() {
    if (process.env.https_proxy) {
        return process.env.https_proxy;
    }
    if (process.env.HTTPS_PROXY) {
        return process.env.HTTPS_PROXY;
    }
    return undefined;
}
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQix5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLHlDQUF5QztBQUN6QywrQkFBK0I7QUFFL0IsK0JBQStCO0FBQy9CLDJDQUFzQztBQUN0QyxvREFBOEM7QUFDOUMsdUVBQW1FO0FBRW5FLDJEQUF1RDtBQUN2RCwrQkFBa0M7QUFHbEMsMERBQTBEO0FBQzFELHlCQUF5QjtBQUN6QixPQUFPLENBQUMsR0FBRyxDQUFDLDBCQUEwQixHQUFHLFVBQVUsQ0FBQztBQUNwRCxPQUFPLENBQUMsR0FBRyxDQUFDLG1DQUFtQyxHQUFHLEdBQUcsQ0FBQztBQTJEdEQsTUFBTSxjQUFjLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFDaEQsTUFBTSwwQkFBMEIsR0FBRyxNQUFNLENBQUMsNEJBQTRCLENBQUMsQ0FBQztBQUV4RTs7Ozs7OztHQU9HO0FBQ0gsTUFBYSxXQUFXO0lBMEJ0QixZQUNtQixZQUF5QztJQUMxRDs7T0FFRztJQUNhLGFBQXFCLEVBQ3BCLGFBQW1DLEVBQUU7UUFMckMsaUJBQVksR0FBWixZQUFZLENBQTZCO1FBSTFDLGtCQUFhLEdBQWIsYUFBYSxDQUFRO1FBQ3BCLGVBQVUsR0FBVixVQUFVLENBQTJCO1FBUnZDLFlBQU8sR0FBRyxJQUFJLHNDQUFpQixFQUFFLENBQUM7SUFTbkQsQ0FBQztJQWhDRDs7Ozs7T0FLRztJQUNJLE1BQU0sQ0FBQyxLQUFLLENBQUMsNEJBQTRCLENBQUMsVUFBOEIsRUFBRTs7UUFDL0UsTUFBTSxVQUFVLEdBQUcsZ0JBQWdCLE9BQUMsT0FBTyxDQUFDLFdBQVcsbUNBQUksRUFBRSxDQUFDLENBQUM7UUFFL0QsTUFBTSxLQUFLLEdBQUcsTUFBTSxvQ0FBZ0IsQ0FBQyxlQUFlLENBQUM7WUFDbkQsT0FBTyxFQUFFLE9BQU8sQ0FB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aEM7SUFDRCxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFO1FBQzNCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUM7S0FDaEM7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLDJCQUEyQjtJQUNsQyxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFO1FBQzdCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUM7S0FDbEM7SUFDRCxJQUFJLE9BQU8sQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFO1FBQzdCLE9BQU8sT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUM7S0FDbEM7SUFDRCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsY0FBYyxDQUFDLFFBQWdCO0lBQ3RDLElBQUk7UUFDRixJQUFJLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUFFLE9BQU8sU0FBUyxDQUFDO1NBQUU7UUFDdkQsT0FBTyxFQUFFLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO0tBQ3pEO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixlQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDVCxPQUFPLFNBQVMsQ0FBQztLQUNsQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBodHRwcyBmcm9tICdodHRwcyc7XG5pbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IENvbmZpZ3VyYXRpb25PcHRpb25zIH0gZnJvbSAnYXdzLXNkay9saWIvY29uZmlnJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzLWV4dHJhJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vLi4vbG9nZ2luZyc7XG5pbXBvcnQgeyBjYWNoZWQgfSBmcm9tICcuLi8uLi91dGlsL2Z1bmN0aW9ucyc7XG5pbXBvcnQgeyBDcmVkZW50aWFsUGx1Z2lucyB9IGZyb20gJy4uL2F3cy1hdXRoL2NyZWRlbnRpYWwtcGx1Z2lucyc7XG5pbXBvcnQgeyBNb2RlIH0gZnJvbSAnLi4vYXdzLWF1dGgvY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgQXdzQ2xpQ29tcGF0aWJsZSB9IGZyb20gJy4vYXdzY2xpLWNvbXBhdGlibGUnO1xuaW1wb3J0IHsgSVNESywgU0RLIH0gZnJvbSAnLi9zZGsnO1xuXG5cbi8vIFNvbWUgY29uZmlndXJhdGlvbiB0aGF0IGNhbiBvbmx5IGJlIGFjaGlldmVkIGJ5IHNldHRpbmdcbi8vIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbnByb2Nlc3MuZW52LkFXU19TVFNfUkVHSU9OQUxfRU5EUE9JTlRTID0gJ3JlZ2lvbmFsJztcbnByb2Nlc3MuZW52LkFXU19OT0RFSlNfQ09OTkVDVElPTl9SRVVTRV9FTkFCTEVEID0gJzEnO1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHRoZSBkZWZhdWx0IFNESyBwcm92aWRlclxuICovXG5leHBvcnQgaW50ZXJmYWNlIFNka1Byb3ZpZGVyT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQcm9maWxlIHRvIHJlYWQgZnJvbSB+Ly5hd3NcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBwcm9maWxlXG4gICAqL1xuICByZWFkb25seSBwcm9maWxlPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIHNob3VsZCBjaGVjayBmb3IgRUMyIGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQXV0b2RldGVjdFxuICAgKi9cbiAgcmVhZG9ubHkgZWMyY3JlZHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIHNob3VsZCBjaGVjayBmb3IgY29udGFpbmVyIGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQXV0b2RldGVjdFxuICAgKi9cbiAgcmVhZG9ubHkgY29udGFpbmVyQ3JlZHM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBIVFRQIG9wdGlvbnMgZm9yIFNES1xuICAgKi9cbiAgcmVhZG9ubHkgaHR0cE9wdGlvbnM/OiBTZGtIdHRwT3B0aW9ucztcbn1cblxuLyoqXG4gKiBPcHRpb25zIGZvciBpbmRpdmlkdWFsIFNES3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZGtIdHRwT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBQcm94eSBhZGRyZXNzIHRvIHVzZVxuICAgKlxuICAgKiBAZGVmYXVsdCBObyBwcm94eVxuICAgKi9cbiAgcmVhZG9ubHkgcHJveHlBZGRyZXNzPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBBIHBhdGggdG8gYSBjZXJ0aWZpY2F0ZSBidW5kbGUgdGhhdCBjb250YWlucyBhIGNlcnQgdG8gYmUgdHJ1c3RlZC5cbiAgICpcbiAgICogQGRlZmF1bHQgTm8gY2VydGlmaWNhdGUgYnVuZGxlXG4gICAqL1xuICByZWFkb25seSBjYUJ1bmRsZVBhdGg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBjdXN0b20gdXNlciBhZ2VudCB0byB1c2UuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gPHBhY2thZ2UtbmFtZT4vPHBhY2thZ2UtdmVyc2lvbj5cbiAgICovXG4gIHJlYWRvbmx5IHVzZXJBZ2VudD86IHN0cmluZztcbn1cblxuY29uc3QgQ0FDSEVEX0FDQ09VTlQgPSBTeW1ib2woJ2NhY2hlZF9hY2NvdW50Jyk7XG5jb25zdCBDQUNIRURfREVGQVVMVF9DUkVERU5USUFMUyA9IFN5bWJvbCgnY2FjaGVkX2RlZmF1bHRfY3JlZGVudGlhbHMnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGluc3RhbmNlcyBvZiB0aGUgQVdTIFNESyBhcHByb3ByaWF0ZSBmb3IgYSBnaXZlbiBhY2NvdW50L3JlZ2lvblxuICpcbiAqIElmIGFuIGVudmlyb25tZW50IGlzIGdpdmVuIGFuZCB0aGUgY3VycmVudCBjcmVkZW50aWFscyBhcmUgTk9UIGZvciB0aGUgaW5kaWNhdGVkXG4gKiBhY2NvdW50LCB3aWxsIGFsc28gc2VhcmNoIHRoZSBzZXQgb2YgY3JlZGVudGlhbCBwbHVnaW4gcHJvdmlkZXJzLlxuICpcbiAqIElmIG5vIGVudmlyb25tZW50IGlzIGdpdmVuLCB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyB3aWxsIGFsd2F5cyBiZSB1c2VkLlxuICovXG5leHBvcnQgY2xhc3MgU2RrUHJvdmlkZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFNka1Byb3ZpZGVyIHdoaWNoIGdldHMgaXRzIGRlZmF1bHRzIGluIGEgd2F5IHRoYXQgYmVoYXZlcyBsaWtlIHRoZSBBV1MgQ0xJIGRvZXNcbiAgICpcbiAgICogVGhlIEFXUyBTREsgZm9yIEpTIGJlaGF2ZXMgc2xpZ2h0bHkgZGlmZmVyZW50bHkgZnJvbSB0aGUgQVdTIENMSSBpbiBhIG51bWJlciBvZiB3YXlzOyBzZWUgdGhlXG4gICAqIGNsYXNzIGBBd3NDbGlDb21wYXRpYmxlYCBmb3IgdGhlIGRldGFpbHMuXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGFzeW5jIHdpdGhBd3NDbGlDb21wYXRpYmxlRGVmYXVsdHMob3B0aW9uczogU2RrUHJvdmlkZXJPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBzZGtPcHRpb25zID0gcGFyc2VIdHRwT3B0aW9ucyhvcHRpb25zLmh0dHBPcHRpb25zID8/IHt9KTtcblxuICAgIGNvbnN0IGNoYWluID0gYXdhaXQgQXdzQ2xpQ29tcGF0aWJsZS5jcmVkZW50aWFsQ2hhaW4oe1xuICAgICAgcHJvZmlsZTogb3B0aW9ucy5wcm9maWxlLFxuICAgICAgZWMyaW5zdGFuY2U6IG9wdGlvbnMuZWMyY3JlZHMsXG4gICAgICBjb250YWluZXJDcmVkczogb3B0aW9ucy5jb250YWluZXJDcmVkcyxcbiAgICAgIGh0dHBPcHRpb25zOiBzZGtPcHRpb25zLmh0dHBPcHRpb25zLFxuICAgIH0pO1xuICAgIGNvbnN0IHJlZ2lvbiA9IGF3YWl0IEF3c0NsaUNvbXBhdGlibGUucmVnaW9uKHtcbiAgICAgIHByb2ZpbGU6IG9wdGlvbnMucHJvZmlsZSxcbiAgICAgIGVjMmluc3RhbmNlOiBvcHRpb25zLmVjMmNyZWRzLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIG5ldyBTZGtQcm92aWRlcihjaGFpbiwgcmVnaW9uLCBzZGtPcHRpb25zKTtcbiAgfVxuXG4gIHByaXZhdGUgcmVhZG9ubHkgcGx1Z2lucyA9IG5ldyBDcmVkZW50aWFsUGx1Z2lucygpO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRDaGFpbjogQVdTLkNyZWRlbnRpYWxQcm92aWRlckNoYWluLFxuICAgIC8qKlxuICAgICAqIERlZmF1bHQgcmVnaW9uXG4gICAgICovXG4gICAgcHVibGljIHJlYWRvbmx5IGRlZmF1bHRSZWdpb246IHN0cmluZyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNka09wdGlvbnM6IENvbmZpZ3VyYXRpb25PcHRpb25zID0ge30pIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gU0RLIHdoaWNoIGNhbiBkbyBvcGVyYXRpb25zIGluIHRoZSBnaXZlbiBlbnZpcm9ubWVudFxuICAgKlxuICAgKiBUaGUgYGVudmlyb25tZW50YCBwYXJhbWV0ZXIgaXMgcmVzb2x2ZWQgZmlyc3QgKHNlZSBgcmVzb2x2ZUVudmlyb25tZW50KClgKS5cbiAgICovXG4gIHB1YmxpYyBhc3luYyBmb3JFbnZpcm9ubWVudChlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPElTREs+IHtcbiAgICBjb25zdCBlbnYgPSBhd2FpdCB0aGlzLnJlc29sdmVFbnZpcm9ubWVudChlbnZpcm9ubWVudCk7XG4gICAgY29uc3QgY3JlZHMgPSBhd2FpdCB0aGlzLm9idGFpbkNyZWRlbnRpYWxzKGVudi5hY2NvdW50LCBtb2RlKTtcbiAgICByZXR1cm4gbmV3IFNESyhjcmVkcywgZW52LnJlZ2lvbiwgdGhpcy5zZGtPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gYW4gU0RLIHdoaWNoIHVzZXMgYXNzdW1lZCByb2xlIGNyZWRlbnRpYWxzXG4gICAqXG4gICAqIFRoZSBiYXNlIGNyZWRlbnRpYWxzIHVzZWQgdG8gcmV0cmlldmUgdGhlIGFzc3VtZWQgcm9sZSBjcmVkZW50aWFscyB3aWxsIGJlIHRoZVxuICAgKiBjdXJyZW50IGNyZWRlbnRpYWxzIChubyBwbHVnaW4gbG9va3VwIHdpbGwgYmUgZG9uZSEpLlxuICAgKlxuICAgKiBJZiBgcmVnaW9uYCBpcyB1bmRlZmluZWQsIHRoZSBkZWZhdWx0IHZhbHVlIHdpbGwgYmUgdXNlZC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB3aXRoQXNzdW1lZFJvbGUocm9sZUFybjogc3RyaW5nLCBleHRlcm5hbElkOiBzdHJpbmcgfCB1bmRlZmluZWQsIHJlZ2lvbjogc3RyaW5nIHwgdW5kZWZpbmVkKSB7XG4gICAgZGVidWcoYEFzc3VtaW5nIHJvbGUgJyR7cm9sZUFybn0nLmApO1xuICAgIHJlZ2lvbiA9IHJlZ2lvbiA/PyB0aGlzLmRlZmF1bHRSZWdpb247XG5cbiAgICBjb25zdCBjcmVkcyA9IG5ldyBBV1MuQ2hhaW5hYmxlVGVtcG9yYXJ5Q3JlZGVudGlhbHMoe1xuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIFJvbGVBcm46IHJvbGVBcm4sXG4gICAgICAgIC4uLmV4dGVybmFsSWQgPyB7IEV4dGVybmFsSWQ6IGV4dGVybmFsSWQgfSA6IHt9LFxuICAgICAgICBSb2xlU2Vzc2lvbk5hbWU6IGBhd3MtY2RrLSR7b3MudXNlckluZm8oKS51c2VybmFtZX1gLFxuICAgICAgfSxcbiAgICAgIHN0c0NvbmZpZzoge1xuICAgICAgICByZWdpb24sXG4gICAgICAgIC4uLnRoaXMuc2RrT3B0aW9ucyxcbiAgICAgIH0sXG4gICAgICBtYXN0ZXJDcmVkZW50aWFsczogYXdhaXQgdGhpcy5kZWZhdWx0Q3JlZGVudGlhbHMoKSxcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgU0RLKGNyZWRzLCByZWdpb24sIHRoaXMuc2RrT3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgZW52aXJvbm1lbnQgZm9yIGEgc3RhY2tcbiAgICpcbiAgICogUmVwbGFjZXMgdGhlIG1hZ2ljIHZhbHVlcyBgVU5LTk9XTl9SRUdJT05gIGFuZCBgVU5LTk9XTl9BQ0NPVU5UYFxuICAgKiB3aXRoIHRoZSBkZWZhdWx0cyBmb3IgdGhlIGN1cnJlbnQgU0RLIGNvbmZpZ3VyYXRpb24gKGB+Ly5hd3MvY29uZmlnYCBvclxuICAgKiBvdGhlcndpc2UpLlxuICAgKlxuICAgKiBJdCBpcyBhbiBlcnJvciBpZiBgVU5LTk9XTl9BQ0NPVU5UYCBpcyB1c2VkIGJ1dCB0aGUgdXNlciBoYXNuJ3QgY29uZmlndXJlZFxuICAgKiBhbnkgU0RLIGNyZWRlbnRpYWxzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlc29sdmVFbnZpcm9ubWVudChlbnY6IGN4YXBpLkVudmlyb25tZW50KTogUHJvbWlzZTxjeGFwaS5FbnZpcm9ubWVudD4ge1xuICAgIGNvbnN0IHJlZ2lvbiA9IGVudi5yZWdpb24gIT09IGN4YXBpLlVOS05PV05fUkVHSU9OID8gZW52LnJlZ2lvbiA6IHRoaXMuZGVmYXVsdFJlZ2lvbjtcbiAgICBjb25zdCBhY2NvdW50ID0gZW52LmFjY291bnQgIT09IGN4YXBpLlVOS05PV05fQUNDT1VOVCA/IGVudi5hY2NvdW50IDogKGF3YWl0IHRoaXMuZGVmYXVsdEFjY291bnQoKSk/LmFjY291bnRJZDtcblxuICAgIGlmICghYWNjb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVzb2x2ZSBBV1MgYWNjb3VudCB0byB1c2UuIEl0IG11c3QgYmUgZWl0aGVyIGNvbmZpZ3VyZWQgd2hlbiB5b3UgZGVmaW5lIHlvdXIgQ0RLIG9yIHRocm91Z2ggdGhlIGVudmlyb25tZW50Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHJlZ2lvbixcbiAgICAgIGFjY291bnQsXG4gICAgICBuYW1lOiBjeGFwaS5FbnZpcm9ubWVudFV0aWxzLmZvcm1hdChhY2NvdW50LCByZWdpb24pLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFjY291bnQgd2UnZCBhdXRoIGludG8gaWYgd2UgdXNlZCBkZWZhdWx0IGNyZWRlbnRpYWxzLlxuICAgKlxuICAgKiBEZWZhdWx0IGNyZWRlbnRpYWxzIGFyZSB0aGUgc2V0IG9mIGFtYmllbnRseSBjb25maWd1cmVkIGNyZWRlbnRpYWxzIHVzaW5nXG4gICAqIG9uZSBvZiB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVzLCBvciB+Ly5hd3MvY3JlZGVudGlhbHMsIG9yIHRoZSAqb25lKlxuICAgKiBwcm9maWxlIHRoYXQgd2FzIHBhc3NlZCBpbnRvIHRoZSBDTEkuXG4gICAqXG4gICAqIE1pZ2h0IHJldHVybiB1bmRlZmluZWQgaWYgdGhlcmUgYXJlIG5vIGRlZmF1bHQvYW1iaWVudCBjcmVkZW50aWFsc1xuICAgKiBhdmFpbGFibGUgKGluIHdoaWNoIGNhc2UgdGhlIHVzZXIgc2hvdWxkIGJldHRlciBob3BlIHRoZXkgaGF2ZVxuICAgKiBjcmVkZW50aWFsIHBsdWdpbnMgY29uZmlndXJlZCkuXG4gICAqXG4gICAqIFVzZXMgYSBjYWNoZSB0byBhdm9pZCBTVFMgY2FsbHMgaWYgd2UgZG9uJ3QgbmVlZCAnZW0uXG4gICAqL1xuICBwdWJsaWMgZGVmYXVsdEFjY291bnQoKTogUHJvbWlzZTxBY2NvdW50IHwgdW5kZWZpbmVkPiB7XG4gICAgcmV0dXJuIGNhY2hlZCh0aGlzLCBDQUNIRURfQUNDT1VOVCwgYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlZHMgPSBhd2FpdCB0aGlzLmRlZmF1bHRDcmVkZW50aWFscygpO1xuXG4gICAgICAgIGNvbnN0IGFjY2Vzc0tleUlkID0gY3JlZHMuYWNjZXNzS2V5SWQ7XG4gICAgICAgIGlmICghYWNjZXNzS2V5SWQpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byByZXNvbHZlIEFXUyBjcmVkZW50aWFscyAoc2V0dXAgd2l0aCBcImF3cyBjb25maWd1cmVcIiknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhd2FpdCBuZXcgU0RLKGNyZWRzLCB0aGlzLmRlZmF1bHRSZWdpb24sIHRoaXMuc2RrT3B0aW9ucykuY3VycmVudEFjY291bnQoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZGVidWcoJ1VuYWJsZSB0byBkZXRlcm1pbmUgdGhlIGRlZmF1bHQgQVdTIGFjY291bnQ6JywgZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGNyZWRlbnRpYWxzIGZvciB0aGUgZ2l2ZW4gYWNjb3VudCBJRCBpbiB0aGUgZ2l2ZW4gbW9kZVxuICAgKlxuICAgKiBVc2UgdGhlIGN1cnJlbnQgY3JlZGVudGlhbHMgaWYgdGhlIGRlc3RpbmF0aW9uIGFjY291bnQgbWF0Y2hlcyB0aGUgY3VycmVudCBjcmVkZW50aWFscycgYWNjb3VudC5cbiAgICogT3RoZXJ3aXNlIHRyeSBhbGwgY3JlZGVudGlhbCBwbHVnaW5zLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFzeW5jIG9idGFpbkNyZWRlbnRpYWxzKGFjY291bnRJZDogc3RyaW5nLCBtb2RlOiBNb2RlKTogUHJvbWlzZTxBV1MuQ3JlZGVudGlhbHM+IHtcbiAgICAvLyBGaXJzdCB0cnkgJ2N1cnJlbnQnIGNyZWRlbnRpYWxzXG4gICAgY29uc3QgZGVmYXVsdEFjY291bnRJZCA9IChhd2FpdCB0aGlzLmRlZmF1bHRBY2NvdW50KCkpPy5hY2NvdW50SWQ7XG4gICAgaWYgKGRlZmF1bHRBY2NvdW50SWQgPT09IGFjY291bnRJZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENyZWRlbnRpYWxzKCk7XG4gICAgfVxuXG4gICAgLy8gVGhlbiB0cnkgdGhlIHBsdWdpbnNcbiAgICBjb25zdCBwbHVnaW5DcmVkcyA9IGF3YWl0IHRoaXMucGx1Z2lucy5mZXRjaENyZWRlbnRpYWxzRm9yKGFjY291bnRJZCwgbW9kZSk7XG4gICAgaWYgKHBsdWdpbkNyZWRzKSB7XG4gICAgICByZXR1cm4gcGx1Z2luQ3JlZHM7XG4gICAgfVxuXG4gICAgLy8gTm8gbHVjaywgZm9ybWF0IGEgdXNlZnVsIGVycm9yIG1lc3NhZ2VcbiAgICBjb25zdCBlcnJvciA9IFtgTmVlZCB0byBwZXJmb3JtIEFXUyBjYWxscyBmb3IgYWNjb3VudCAke2FjY291bnRJZH1gXTtcbiAgICBlcnJvci5wdXNoKGRlZmF1bHRBY2NvdW50SWQgPyBgYnV0IHRoZSBjdXJyZW50IGNyZWRlbnRpYWxzIGFyZSBmb3IgJHtkZWZhdWx0QWNjb3VudElkfWAgOiAnYnV0IG5vIGNyZWRlbnRpYWxzIGhhdmUgYmVlbiBjb25maWd1cmVkJyk7XG4gICAgaWYgKHRoaXMucGx1Z2lucy5hdmFpbGFibGVQbHVnaW5OYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICBlcnJvci5wdXNoKGBhbmQgbm9uZSBvZiB0aGVzZSBwbHVnaW5zIGZvdW5kIGFueTogJHt0aGlzLnBsdWdpbnMuYXZhaWxhYmxlUGx1Z2luTmFtZXMuam9pbignLCAnKX1gKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYCR7ZXJyb3Iuam9pbignLCAnKX0uYCk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgZGVmYXVsdCBjaGFpbiB0byB0aGUgZmlyc3Qgc2V0IG9mIGNyZWRlbnRpYWxzIHRoYXQgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBwcml2YXRlIGRlZmF1bHRDcmVkZW50aWFscygpOiBQcm9taXNlPEFXUy5DcmVkZW50aWFscz4ge1xuICAgIHJldHVybiBjYWNoZWQodGhpcywgQ0FDSEVEX0RFRkFVTFRfQ1JFREVOVElBTFMsICgpID0+IHtcbiAgICAgIGRlYnVnKCdSZXNvbHZpbmcgZGVmYXVsdCBjcmVkZW50aWFscycpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENoYWluLnJlc29sdmVQcm9taXNlKCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBBV1MgYWNjb3VudFxuICpcbiAqIEFuIEFXUyBhY2NvdW50IGFsd2F5cyBleGlzdHMgaW4gb25seSBvbmUgcGFydGl0aW9uLiBVc3VhbGx5IHdlIGRvbid0IGNhcmUgYWJvdXRcbiAqIHRoZSBwYXJ0aXRpb24sIGJ1dCB3aGVuIHdlIG5lZWQgdG8gZm9ybSBBUk5zIHdlIGRvLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIEFjY291bnQge1xuICAvKipcbiAgICogVGhlIGFjY291bnQgbnVtYmVyXG4gICAqL1xuICByZWFkb25seSBhY2NvdW50SWQ6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIHBhcnRpdGlvbiAoJ2F3cycgb3IgJ2F3cy1jbicgb3Igb3RoZXJ3aXNlKVxuICAgKi9cbiAgcmVhZG9ubHkgcGFydGl0aW9uOiBzdHJpbmc7XG59XG5cbi8qKlxuICogR2V0IEhUVFAgb3B0aW9ucyBmb3IgdGhlIFNES1xuICpcbiAqIFJlYWQgZnJvbSB1c2VyIGlucHV0IG9yIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiBSZXR1cm5zIGEgY29tcGxldGUgYENvbmZpZ3VyYXRpb25PcHRpb25zYCBvYmplY3QgYmVjYXVzZSB0aGF0J3Mgd2hlcmVcbiAqIGBjdXN0b21Vc2VyQWdlbnRgIGxpdmVzLCBidXQgYGh0dHBPcHRpb25zYCBpcyB0aGUgbW9zdCBpbXBvcnRhbnQgYXR0cmlidXRlLlxuICovXG5mdW5jdGlvbiBwYXJzZUh0dHBPcHRpb25zKG9wdGlvbnM6IFNka0h0dHBPcHRpb25zKSB7XG4gIGNvbnN0IGNvbmZpZzogQ29uZmlndXJhdGlvbk9wdGlvbnMgPSB7fTtcbiAgY29uZmlnLmh0dHBPcHRpb25zID0ge307XG5cbiAgbGV0IHVzZXJBZ2VudCA9IG9wdGlvbnMudXNlckFnZW50O1xuICBpZiAodXNlckFnZW50ID09IG51bGwpIHtcbiAgICAvLyBGaW5kIHRoZSBwYWNrYWdlLmpzb24gZnJvbSB0aGUgbWFpbiB0b29sa2l0XG4gICAgY29uc3QgcGtnID0gSlNPTi5wYXJzZShyZWFkSWZQb3NzaWJsZShwYXRoLmpvaW4oX19kaXJuYW1lLCAnLi4nLCAnLi4nLCAnLi4nLCAncGFja2FnZS5qc29uJykpID8/ICd7fScpO1xuICAgIHVzZXJBZ2VudCA9IGAke3BrZy5uYW1lfS8ke3BrZy52ZXJzaW9ufWA7XG4gIH1cbiAgY29uZmlnLmN1c3RvbVVzZXJBZ2VudCA9IHVzZXJBZ2VudDtcblxuICBjb25zdCBwcm94eUFkZHJlc3MgPSBvcHRpb25zLnByb3h5QWRkcmVzcyB8fCBodHRwc1Byb3h5RnJvbUVudmlyb25tZW50KCk7XG4gIGNvbnN0IGNhQnVuZGxlUGF0aCA9IG9wdGlvbnMuY2FCdW5kbGVQYXRoIHx8IGNhQnVuZGxlUGF0aEZyb21FbnZpcm9ubWVudCgpO1xuXG4gIGlmIChwcm94eUFkZHJlc3MgJiYgY2FCdW5kbGVQYXRoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBBdCB0aGUgbW9tZW50LCBjYW5ub3Qgc3BlY2lmeSBQcm94eSAoJHtwcm94eUFkZHJlc3N9KSBhbmQgQ0EgQnVuZGxlICgke2NhQnVuZGxlUGF0aH0pIGF0IHRoZSBzYW1lIHRpbWUuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYXdzL2F3cy1jZGsvaXNzdWVzLzU4MDRgKTtcbiAgICAvLyBNYXliZSBpdCdzIHBvc3NpYmxlIGFmdGVyIGFsbCwgYnV0IEkndmUgYmVlbiBzdGFyaW5nIGF0XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1Rvb1RhbGxOYXRlL25vZGUtcHJveHktYWdlbnQvYmxvYi9tYXN0ZXIvaW5kZXguanMjTDc5XG4gICAgLy8gYSB3aGlsZSBub3cgdHJ5aW5nIHRvIGZpZ3VyZSBvdXQgd2hhdCB0byBwYXNzIGluIHNvIHRoYXQgdGhlIHVuZGVybHlpbmcgQWdlbnRcbiAgICAvLyBvYmplY3Qgd2lsbCBnZXQgdGhlICdjYScgYXJndW1lbnQuIEl0J3Mgbm90IHRyaXZpYWwgYW5kIEkgZG9uJ3Qgd2FudCB0byByaXNrIGl0LlxuICB9XG5cbiAgaWYgKHByb3h5QWRkcmVzcykgeyAvLyBJZ25vcmUgZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2VcbiAgICAvLyBodHRwczovL2F3cy5hbWF6b24uY29tL2Jsb2dzL2RldmVsb3Blci91c2luZy10aGUtYXdzLXNkay1mb3ItamF2YXNjcmlwdC1mcm9tLWJlaGluZC1hLXByb3h5L1xuICAgIGRlYnVnKCdVc2luZyBwcm94eSBzZXJ2ZXI6ICVzJywgcHJveHlBZGRyZXNzKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICAgIGNvbnN0IFByb3h5QWdlbnQ6IGFueSA9IHJlcXVpcmUoJ3Byb3h5LWFnZW50Jyk7XG4gICAgY29uZmlnLmh0dHBPcHRpb25zLmFnZW50ID0gbmV3IFByb3h5QWdlbnQocHJveHlBZGRyZXNzKTtcbiAgfVxuICBpZiAoY2FCdW5kbGVQYXRoKSB7XG4gICAgZGVidWcoJ1VzaW5nIENBIGJ1bmRsZSBwYXRoOiAlcycsIGNhQnVuZGxlUGF0aCk7XG4gICAgY29uZmlnLmh0dHBPcHRpb25zLmFnZW50ID0gbmV3IGh0dHBzLkFnZW50KHtcbiAgICAgIGNhOiByZWFkSWZQb3NzaWJsZShjYUJ1bmRsZVBhdGgpLFxuICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGNvbmZpZztcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gdGhlIGNvbmZpZ3VyZWQgSFRUUFMgcHJveHkgYWRkcmVzc1xuICovXG5mdW5jdGlvbiBodHRwc1Byb3h5RnJvbUVudmlyb25tZW50KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChwcm9jZXNzLmVudi5odHRwc19wcm94eSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5odHRwc19wcm94eTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFkpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuSFRUUFNfUFJPWFk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBGaW5kIGFuZCByZXR1cm4gYSBDQSBjZXJ0aWZpY2F0ZSBidW5kbGUgcGF0aCB0byBiZSBwYXNzZWQgaW50byB0aGUgU0RLLlxuICovXG5mdW5jdGlvbiBjYUJ1bmRsZVBhdGhGcm9tRW52aXJvbm1lbnQoKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgaWYgKHByb2Nlc3MuZW52LmF3c19jYV9idW5kbGUpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuYXdzX2NhX2J1bmRsZTtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuQVdTX0NBX0JVTkRMRSkge1xuICAgIHJldHVybiBwcm9jZXNzLmVudi5BV1NfQ0FfQlVORExFO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogUmVhZCBhIGZpbGUgaWYgaXQgZXhpc3RzLCBvciByZXR1cm4gdW5kZWZpbmVkXG4gKlxuICogTm90IGFzeW5jIGJlY2F1c2UgaXQgaXMgdXNlZCBpbiB0aGUgY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gcmVhZElmUG9zc2libGUoZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHRyeSB7XG4gICAgaWYgKCFmcy5wYXRoRXhpc3RzU3luYyhmaWxlbmFtZSkpIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZW5hbWUsIHsgZW5jb2Rpbmc6ICd1dGYtOCcgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZyhlKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59Il19