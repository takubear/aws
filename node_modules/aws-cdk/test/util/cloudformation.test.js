"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const cloudformation_1 = require("../../lib/api/util/cloudformation");
const mock_sdk_1 = require("./mock-sdk");
const PARAM = 'TheParameter';
const DEFAULT = 'TheDefault';
const OVERRIDE = 'TheOverride';
const USE_OVERRIDE = { ParameterKey: PARAM, ParameterValue: OVERRIDE };
const USE_PREVIOUS = { ParameterKey: PARAM, UsePreviousValue: true };
let sdkProvider;
let cfnMocks;
let cfn;
beforeEach(async () => {
    sdkProvider = new mock_sdk_1.MockSdkProvider();
    cfnMocks = {
        describeStacks: jest.fn()
            // No stacks exist
            .mockImplementation(() => ({ Stacks: [] })),
    };
    sdkProvider.stubCloudFormation(cfnMocks);
    cfn = (await sdkProvider.forEnvironment()).cloudFormation();
});
test('A non-existent stack pretends to have an empty template', async () => {
    // WHEN
    const stack = await cloudformation_1.CloudFormationStack.lookup(cfn, 'Dummy');
    // THEN
    expect(await stack.template()).toEqual({});
});
test.each([
    [false, false],
    [false, true],
    [true, false],
    [true, true],
])('given override, always use the override (parameter has a default: %p, parameter previously supplied: %p)', (haveDefault, havePrevious) => {
    expect(makeParams(haveDefault, havePrevious, true)).toEqual({
        apiParameters: [USE_OVERRIDE],
        changed: true,
    });
});
test('no default, no prev, no override => error', () => {
    expect(() => makeParams(false, false, false)).toThrow(/missing a value: TheParameter/);
});
test('no default, yes prev, no override => use previous', () => {
    expect(makeParams(false, true, false)).toEqual({
        apiParameters: [USE_PREVIOUS],
        changed: false,
    });
});
test('default, no prev, no override => empty param set', () => {
    expect(makeParams(true, false, false)).toEqual({
        apiParameters: [],
        changed: false,
    });
});
test('default, prev, no override => use previous', () => {
    expect(makeParams(true, true, false)).toEqual({
        apiParameters: [USE_PREVIOUS],
        changed: false,
    });
});
test('if a parameter is retrieved from SSM, the parameters always count as changed', () => {
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: {
                Type: 'AWS::SSM::Parameter::Name',
                Default: '/Some/Key',
            },
        },
    });
    // If we don't pass a new value
    expect(params.diff({}, { Foo: '/Some/Key' }).changed).toEqual(true);
    // If we do pass a new value but it's the same as the old one
    expect(params.diff({ Foo: '/Some/Key' }, { Foo: '/Some/Key' }).changed).toEqual(true);
});
test('empty string is a valid update value', () => {
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: { Type: 'String', Default: 'Foo' },
        },
    });
    expect(params.diff({ Foo: '' }, { Foo: 'ThisIsOld' }).apiParameters).toEqual([
        { ParameterKey: 'Foo', ParameterValue: '' },
    ]);
});
test('unknown parameter in overrides, pass it anyway', () => {
    // Not sure if we really want this. It seems like it would be nice
    // to not pass parameters that aren't expected, given that CFN will
    // just error out. But maybe we want to be warned of typos...
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            Foo: { Type: 'String', Default: 'Foo' },
        },
    });
    expect(params.diff({ Bar: 'Bar' }, {}).apiParameters).toEqual([
        { ParameterKey: 'Bar', ParameterValue: 'Bar' },
    ]);
});
function makeParams(defaultValue, hasPrevValue, override) {
    const params = cloudformation_1.TemplateParameters.fromTemplate({
        Parameters: {
            [PARAM]: {
                Type: 'String',
                Default: defaultValue ? DEFAULT : undefined,
            },
        },
    });
    const prevParams = hasPrevValue ? { [PARAM]: 'Foo' } : {};
    const stackParams = params.diff({ [PARAM]: override ? OVERRIDE : undefined }, prevParams);
    return { apiParameters: stackParams.apiParameters, changed: stackParams.changed };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24udGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImNsb3VkZm9ybWF0aW9uLnRlc3QudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxzRUFBNEY7QUFDNUYseUNBQWdGO0FBRWhGLE1BQU0sS0FBSyxHQUFHLGNBQWMsQ0FBQztBQUM3QixNQUFNLE9BQU8sR0FBRyxZQUFZLENBQUM7QUFDN0IsTUFBTSxRQUFRLEdBQUcsYUFBYSxDQUFDO0FBRS9CLE1BQU0sWUFBWSxHQUFHLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxjQUFjLEVBQUUsUUFBUSxFQUFFLENBQUM7QUFDdkUsTUFBTSxZQUFZLEdBQUcsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLGdCQUFnQixFQUFFLElBQUksRUFBRSxDQUFDO0FBRXJFLElBQUksV0FBNEIsQ0FBQztBQUNqQyxJQUFJLFFBQStELENBQUM7QUFDcEUsSUFBSSxHQUF1QixDQUFDO0FBQzVCLFVBQVUsQ0FBQyxLQUFLLElBQUksRUFBRTtJQUNwQixXQUFXLEdBQUcsSUFBSSwwQkFBZSxFQUFFLENBQUM7SUFFcEMsUUFBUSxHQUFHO1FBQ1QsY0FBYyxFQUFFLElBQUksQ0FBQyxFQUFFLEVBQUU7WUFDdkIsa0JBQWtCO2FBQ2pCLGtCQUFrQixDQUFDLEdBQUcsRUFBRSxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztLQUM5QyxDQUFDO0lBQ0YsV0FBVyxDQUFDLGtCQUFrQixDQUFDLFFBQWUsQ0FBQyxDQUFDO0lBQ2hELEdBQUcsR0FBRyxDQUFDLE1BQU0sV0FBVyxDQUFDLGNBQWMsRUFBRSxDQUFDLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDOUQsQ0FBQyxDQUFDLENBQUM7QUFFSCxJQUFJLENBQUMseURBQXlELEVBQUUsS0FBSyxJQUFJLEVBQUU7SUFDekUsT0FBTztJQUNQLE1BQU0sS0FBSyxHQUFHLE1BQU0sb0NBQW1CLENBQUMsTUFBTSxDQUFD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LE9BQU8sRUFBRSxZQUFZLENBQUMsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsU0FBUzthQUM1QztTQUNGO0tBQ0YsQ0FBQyxDQUFDO0lBQ0gsTUFBTSxVQUFVLEdBQTJCLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDbEYsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsUUFBUSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFNBQVMsRUFBRSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBRTFGLE9BQU8sRUFBRSxhQUFhLEVBQUUsV0FBVyxDQUFDLGFBQWEsRUFBRSxPQUFPLEVBQUUsV0FBVyxDQUFDLE9BQU8sRUFBRSxDQUFDO0FBQ3BGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDbG91ZEZvcm1hdGlvblN0YWNrLCBUZW1wbGF0ZVBhcmFtZXRlcnMgfSBmcm9tICcuLi8uLi9saWIvYXBpL3V0aWwvY2xvdWRmb3JtYXRpb24nO1xuaW1wb3J0IHsgTW9ja2VkT2JqZWN0LCBNb2NrU2RrUHJvdmlkZXIsIFN5bmNIYW5kbGVyU3Vic2V0T2YgfSBmcm9tICcuL21vY2stc2RrJztcblxuY29uc3QgUEFSQU0gPSAnVGhlUGFyYW1ldGVyJztcbmNvbnN0IERFRkFVTFQgPSAnVGhlRGVmYXVsdCc7XG5jb25zdCBPVkVSUklERSA9ICdUaGVPdmVycmlkZSc7XG5cbmNvbnN0IFVTRV9PVkVSUklERSA9IHsgUGFyYW1ldGVyS2V5OiBQQVJBTSwgUGFyYW1ldGVyVmFsdWU6IE9WRVJSSURFIH07XG5jb25zdCBVU0VfUFJFVklPVVMgPSB7IFBhcmFtZXRlcktleTogUEFSQU0sIFVzZVByZXZpb3VzVmFsdWU6IHRydWUgfTtcblxubGV0IHNka1Byb3ZpZGVyOiBNb2NrU2RrUHJvdmlkZXI7XG5sZXQgY2ZuTW9ja3M6IE1vY2tlZE9iamVjdDxTeW5jSGFuZGxlclN1YnNldE9mPEFXUy5DbG91ZEZvcm1hdGlvbj4+O1xubGV0IGNmbjogQVdTLkNsb3VkRm9ybWF0aW9uO1xuYmVmb3JlRWFjaChhc3luYyAoKSA9PiB7XG4gIHNka1Byb3ZpZGVyID0gbmV3IE1vY2tTZGtQcm92aWRlcigpO1xuXG4gIGNmbk1vY2tzID0ge1xuICAgIGRlc2NyaWJlU3RhY2tzOiBqZXN0LmZuKClcbiAgICAgIC8vIE5vIHN0YWNrcyBleGlzdFxuICAgICAgLm1vY2tJbXBsZW1lbnRhdGlvbigoKSA9PiAoeyBTdGFja3M6IFtdIH0pKSxcbiAgfTtcbiAgc2RrUHJvdmlkZXIuc3R1YkNsb3VkRm9ybWF0aW9uKGNmbk1vY2tzIGFzIGFueSk7XG4gIGNmbiA9IChhd2FpdCBzZGtQcm92aWRlci5mb3JFbnZpcm9ubWVudCgpKS5jbG91ZEZvcm1hdGlvbigpO1xufSk7XG5cbnRlc3QoJ0Egbm9uLWV4aXN0ZW50IHN0YWNrIHByZXRlbmRzIHRvIGhhdmUgYW4gZW1wdHkgdGVtcGxhdGUnLCBhc3luYyAoKSA9PiB7XG4gIC8vIFdIRU5cbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sICdEdW1teScpO1xuXG4gIC8vIFRIRU5cbiAgZXhwZWN0KGF3YWl0IHN0YWNrLnRlbXBsYXRlKCkpLnRvRXF1YWwoe30pO1xufSk7XG5cbnRlc3QuZWFjaChbXG4gIFtmYWxzZSwgZmFsc2VdLFxuICBbZmFsc2UsIHRydWVdLFxuICBbdHJ1ZSwgZmFsc2VdLFxuICBbdHJ1ZSwgdHJ1ZV0sXG5dKSgnZ2l2ZW4gb3ZlcnJpZGUsIGFsd2F5cyB1c2UgdGhlIG92ZXJyaWRlIChwYXJhbWV0ZXIgaGFzIGEgZGVmYXVsdDogJXAsIHBhcmFtZXRlciBwcmV2aW91c2x5IHN1cHBsaWVkOiAlcCknLFxuICAoaGF2ZURlZmF1bHQsIGhhdmVQcmV2aW91cykgPT4ge1xuICAgIGV4cGVjdChtYWtlUGFyYW1zKGhhdmVEZWZhdWx0LCBoYXZlUHJldmlvdXMsIHRydWUpKS50b0VxdWFsKHtcbiAgICAgIGFwaVBhcmFtZXRlcnM6IFtVU0VfT1ZFUlJJREVdLFxuICAgICAgY2hhbmdlZDogdHJ1ZSxcbiAgICB9KTtcbiAgfSk7XG5cbnRlc3QoJ25vIGRlZmF1bHQsIG5vIHByZXYsIG5vIG92ZXJyaWRlID0+IGVycm9yJywgKCkgPT4ge1xuICBleHBlY3QoKCkgPT4gbWFrZVBhcmFtcyhmYWxzZSwgZmFsc2UsIGZhbHNlKSkudG9UaHJvdygvbWlzc2luZyBhIHZhbHVlOiBUaGVQYXJhbWV0ZXIvKTtcbn0pO1xuXG50ZXN0KCdubyBkZWZhdWx0LCB5ZXMgcHJldiwgbm8gb3ZlcnJpZGUgPT4gdXNlIHByZXZpb3VzJywgKCkgPT4ge1xuICBleHBlY3QobWFrZVBhcmFtcyhmYWxzZSwgdHJ1ZSwgZmFsc2UpKS50b0VxdWFsKHtcbiAgICBhcGlQYXJhbWV0ZXJzOiBbVVNFX1BSRVZJT1VTXSxcbiAgICBjaGFuZ2VkOiBmYWxzZSxcbiAgfSk7XG59KTtcblxudGVzdCgnZGVmYXVsdCwgbm8gcHJldiwgbm8gb3ZlcnJpZGUgPT4gZW1wdHkgcGFyYW0gc2V0JywgKCkgPT4ge1xuICBleHBlY3QobWFrZVBhcmFtcyh0cnVlLCBmYWxzZSwgZmFsc2UpKS50b0VxdWFsKHtcbiAgICBhcGlQYXJhbWV0ZXJzOiBbXSxcbiAgICBjaGFuZ2VkOiBmYWxzZSxcbiAgfSk7XG59KTtcblxudGVzdCgnZGVmYXVsdCwgcHJldiwgbm8gb3ZlcnJpZGUgPT4gdXNlIHByZXZpb3VzJywgKCkgPT4ge1xuICBleHBlY3QobWFrZVBhcmFtcyh0cnVlLCB0cnVlLCBmYWxzZSkpLnRvRXF1YWwoe1xuICAgIGFwaVBhcmFtZXRlcnM6IFtVU0VfUFJFVklPVVNdLFxuICAgIGNoYW5nZWQ6IGZhbHNlLFxuICB9KTtcbn0pO1xuXG50ZXN0KCdpZiBhIHBhcmFtZXRlciBpcyByZXRyaWV2ZWQgZnJvbSBTU00sIHRoZSBwYXJhbWV0ZXJzIGFsd2F5cyBjb3VudCBhcyBjaGFuZ2VkJywgKCkgPT4ge1xuICBjb25zdCBwYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHtcbiAgICBQYXJhbWV0ZXJzOiB7XG4gICAgICBGb286IHtcbiAgICAgICAgVHlwZTogJ0FXUzo6U1NNOjpQYXJhbWV0ZXI6Ok5hbWUnLFxuICAgICAgICBEZWZhdWx0OiAnL1NvbWUvS2V5JyxcbiAgICAgIH0sXG4gICAgfSxcbiAgfSk7XG5cbiAgLy8gSWYgd2UgZG9uJ3QgcGFzcyBhIG5ldyB2YWx1ZVxuICBleHBlY3QocGFyYW1zLmRpZmYoe30sIHsgRm9vOiAnL1NvbWUvS2V5JyB9KS5jaGFuZ2VkKS50b0VxdWFsKHRydWUpO1xuXG4gIC8vIElmIHdlIGRvIHBhc3MgYSBuZXcgdmFsdWUgYnV0IGl0J3MgdGhlIHNhbWUgYXMgdGhlIG9sZCBvbmVcbiAgZXhwZWN0KHBhcmFtcy5kaWZmKHsgRm9vOiAnL1NvbWUvS2V5JyB9LCB7IEZvbzogJy9Tb21lL0tleScgfSkuY2hhbmdlZCkudG9FcXVhbCh0cnVlKTtcbn0pO1xuXG50ZXN0KCdlbXB0eSBzdHJpbmcgaXMgYSB2YWxpZCB1cGRhdGUgdmFsdWUnLCAoKSA9PiB7XG4gIGNvbnN0IHBhcmFtcyA9IFRlbXBsYXRlUGFyYW1ldGVycy5mcm9tVGVtcGxhdGUoe1xuICAgIFBhcmFtZXRlcnM6IHtcbiAgICAgIEZvbzogeyBUeXBlOiAnU3RyaW5nJywgRGVmYXVsdDogJ0ZvbycgfSxcbiAgICB9LFxuICB9KTtcblxuICBleHBlY3QocGFyYW1zLmRpZmYoeyBGb286ICcnIH0sIHsgRm9vOiAnVGhpc0lzT2xkJyB9KS5hcGlQYXJhbWV0ZXJzKS50b0VxdWFsKFtcbiAgICB7IFBhcmFtZXRlcktleTogJ0ZvbycsIFBhcmFtZXRlclZhbHVlOiAnJyB9LFxuICBdKTtcbn0pO1xuXG50ZXN0KCd1bmtub3duIHBhcmFtZXRlciBpbiBvdmVycmlkZXMsIHBhc3MgaXQgYW55d2F5JywgKCkgPT4ge1xuICAvLyBOb3Qgc3VyZSBpZiB3ZSByZWFsbHkgd2FudCB0aGlzLiBJdCBzZWVtcyBsaWtlIGl0IHdvdWxkIGJlIG5pY2VcbiAgLy8gdG8gbm90IHBhc3MgcGFyYW1ldGVycyB0aGF0IGFyZW4ndCBleHBlY3RlZCwgZ2l2ZW4gdGhhdCBDRk4gd2lsbFxuICAvLyBqdXN0IGVycm9yIG91dC4gQnV0IG1heWJlIHdlIHdhbnQgdG8gYmUgd2FybmVkIG9mIHR5cG9zLi4uXG4gIGNvbnN0IHBhcmFtcyA9IFRlbXBsYXRlUGFyYW1ldGVycy5mcm9tVGVtcGxhdGUoe1xuICAgIFBhcmFtZXRlcnM6IHtcbiAgICAgIEZvbzogeyBUeXBlOiAnU3RyaW5nJywgRGVmYXVsdDogJ0ZvbycgfSxcbiAgICB9LFxuICB9KTtcblxuICBleHBlY3QocGFyYW1zLmRpZmYoeyBCYXI6ICdCYXInIH0sIHt9KS5hcGlQYXJhbWV0ZXJzKS50b0VxdWFsKFtcbiAgICB7IFBhcmFtZXRlcktleTogJ0JhcicsIFBhcmFtZXRlclZhbHVlOiAnQmFyJyB9LFxuICBdKTtcbn0pO1xuXG5mdW5jdGlvbiBtYWtlUGFyYW1zKGRlZmF1bHRWYWx1ZTogYm9vbGVhbiwgaGFzUHJldlZhbHVlOiBib29sZWFuLCBvdmVycmlkZTogYm9vbGVhbikge1xuICBjb25zdCBwYXJhbXMgPSBUZW1wbGF0ZVBhcmFtZXRlcnMuZnJvbVRlbXBsYXRlKHtcbiAgICBQYXJhbWV0ZXJzOiB7XG4gICAgICBbUEFSQU1dOiB7XG4gICAgICAgIFR5cGU6ICdTdHJpbmcnLFxuICAgICAgICBEZWZhdWx0OiBkZWZhdWx0VmFsdWUgPyBERUZBVUxUIDogdW5kZWZpbmVkLFxuICAgICAgfSxcbiAgICB9LFxuICB9KTtcbiAgY29uc3QgcHJldlBhcmFtczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IGhhc1ByZXZWYWx1ZSA/IHsgW1BBUkFNXTogJ0ZvbycgfSA6IHt9O1xuICBjb25zdCBzdGFja1BhcmFtcyA9IHBhcmFtcy5kaWZmKHsgW1BBUkFNXTogb3ZlcnJpZGUgPyBPVkVSUklERSA6IHVuZGVmaW5lZCB9LCBwcmV2UGFyYW1zKTtcblxuICByZXR1cm4geyBhcGlQYXJhbWV0ZXJzOiBzdGFja1BhcmFtcy5hcGlQYXJhbWV0ZXJzLCBjaGFuZ2VkOiBzdGFja1BhcmFtcy5jaGFuZ2VkIH07XG59Il19